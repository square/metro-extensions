package com.squareup.metro.extensions.service

import com.squareup.metro.extensions.ClassIds
import com.squareup.metro.extensions.Keys.ContributesServiceGeneratorKey
import org.jetbrains.kotlin.backend.common.extensions.IrGenerationExtension
import org.jetbrains.kotlin.backend.common.extensions.IrPluginContext
import org.jetbrains.kotlin.backend.common.lower.DeclarationIrBuilder
import org.jetbrains.kotlin.ir.IrStatement
import org.jetbrains.kotlin.ir.UNDEFINED_OFFSET
import org.jetbrains.kotlin.ir.builders.irBlockBody
import org.jetbrains.kotlin.ir.builders.irCall
import org.jetbrains.kotlin.ir.builders.irGet
import org.jetbrains.kotlin.ir.builders.irIfThen
import org.jetbrains.kotlin.ir.builders.irIfThenElse
import org.jetbrains.kotlin.ir.builders.irReturn
import org.jetbrains.kotlin.ir.builders.irString
import org.jetbrains.kotlin.ir.declarations.IrDeclarationOrigin
import org.jetbrains.kotlin.ir.declarations.IrModuleFragment
import org.jetbrains.kotlin.ir.declarations.IrSimpleFunction
import org.jetbrains.kotlin.ir.expressions.impl.IrClassReferenceImpl
import org.jetbrains.kotlin.ir.types.IrSimpleType
import org.jetbrains.kotlin.ir.types.classOrNull
import org.jetbrains.kotlin.ir.types.defaultType
import org.jetbrains.kotlin.ir.types.typeWith
import org.jetbrains.kotlin.ir.visitors.IrElementTransformerVoid
import org.jetbrains.kotlin.ir.visitors.transformChildrenVoid
import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name

/**
 * IR extension that generates method bodies for `@Provides` functions created by
 * [ContributesServiceFir].
 *
 * The FIR phase generates function stubs (signatures without bodies). This extension fills in the
 * bodies during the IR phase. It detects which function pattern to use by checking parameter names
 * — these names form a contract between the FIR and IR phases:
 *
 * 1. **Real service with @FakeMode check** (params: `serviceCreator`, `isFakeMode`):
 *    `if (isFakeMode) error("No fake service provided for ..."); return serviceCreator.create(...)`
 *
 * 2. **Real service under @RealService qualifier** (params: `serviceCreator` only):
 *    `return serviceCreator.create(ReplacedService::class.java)`
 *
 * 3. **Fake/real switcher** (params: `realService`, `fakeService`, `isFakeMode`):
 *    `return if (isFakeMode) fakeService else realService`
 */
@Suppress("DEPRECATION")
internal class ContributesServiceIrExtension : IrGenerationExtension {

  override fun generate(moduleFragment: IrModuleFragment, pluginContext: IrPluginContext) {
    moduleFragment.transformChildrenVoid(ContributesServiceIrTransformer(pluginContext))
  }
}

@Suppress("DEPRECATION")
private class ContributesServiceIrTransformer(private val pluginContext: IrPluginContext) :
  IrElementTransformerVoid() {

  override fun visitSimpleFunction(declaration: IrSimpleFunction): IrStatement {
    // Only process functions generated by our FIR extension.
    val origin = declaration.origin
    if (
      origin !is IrDeclarationOrigin.GeneratedByPlugin ||
        origin.pluginKey != ContributesServiceGeneratorKey
    ) {
      return super.visitSimpleFunction(declaration)
    }
    if (declaration.body != null) return super.visitSimpleFunction(declaration)
    if (!declaration.name.asString().startsWith("provide")) {
      return super.visitSimpleFunction(declaration)
    }

    val allParams = declaration.parameters

    // Detect function pattern by parameter names. These names are the contract between the
    // FIR generator (ContributesServiceFir) and this IR extension.
    val hasRealService = allParams.any { it.name.asString() == PARAM_REAL_SERVICE }
    val hasServiceCreator = allParams.any { it.name.asString() == PARAM_SERVICE_CREATOR }
    val hasIsFakeMode = allParams.any { it.name.asString() == PARAM_IS_FAKE_MODE }

    when {
      hasRealService -> generateSwitcherBody(declaration)
      hasServiceCreator && hasIsFakeMode -> generateRealServiceWithCheckBody(declaration)
      hasServiceCreator -> generateRealServiceProviderBody(declaration)
    }

    return super.visitSimpleFunction(declaration)
  }

  /**
   * Real service with fake mode check (for services without `replaces`).
   *
   * Generates:
   * ```
   * if (isFakeMode) error("No fake service provided for MyService.")
   * return serviceCreator.create(MyService::class.java)
   * ```
   *
   * The `@FakeMode` check catches cases where fake mode is enabled but no fake service was
   * provided (e.g., a `:fake` module wasn't included in the dependency graph).
   */
  private fun generateRealServiceWithCheckBody(declaration: IrSimpleFunction) {
    val serviceType = declaration.returnType
    val serviceClassSymbol =
      (serviceType as? IrSimpleType)?.classOrNull ?: return

    val allParams = declaration.parameters
    val serviceCreatorParam = allParams.first { it.name.asString() == PARAM_SERVICE_CREATOR }
    val isFakeModeParam = allParams.first { it.name.asString() == PARAM_IS_FAKE_MODE }

    val errorFun =
      pluginContext
        .referenceFunctions(CallableId(FqName("kotlin"), Name.identifier("error")))
        .first()

    val createCall = buildServiceCreatorCall(declaration, serviceCreatorParam) ?: return

    val irBuilder = irBuilderFor(declaration)

    declaration.body =
      irBuilder.irBlockBody {
        // if (isFakeMode) error("No fake service provided for MyService.")
        val serviceName = serviceClassSymbol.owner.name.asString()
        val errorCall =
          irCall(errorFun).apply {
            arguments[0] = irString("No fake service provided for $serviceName.")
          }
        +irIfThen(pluginContext.irBuiltIns.unitType, irGet(isFakeModeParam), errorCall)

        // return serviceCreator.create(MyService::class.java)
        +irReturn(createCall)
      }
  }

  /**
   * Real service provider under `@RealService` qualifier (generated for fake service
   * contributions).
   *
   * Generates: `return serviceCreator.create(ReplacedService::class.java)`
   */
  private fun generateRealServiceProviderBody(declaration: IrSimpleFunction) {
    val allParams = declaration.parameters
    val serviceCreatorParam = allParams.first { it.name.asString() == PARAM_SERVICE_CREATOR }

    val createCall = buildServiceCreatorCall(declaration, serviceCreatorParam) ?: return

    val irBuilder = irBuilderFor(declaration)

    declaration.body =
      irBuilder.irBlockBody { +irReturn(createCall) }
  }

  /**
   * Switcher — returns fake or real based on `@FakeMode` (generated for fake service
   * contributions).
   *
   * Generates: `return if (isFakeMode) fakeService else realService`
   */
  private fun generateSwitcherBody(declaration: IrSimpleFunction) {
    val allParams = declaration.parameters
    val realServiceParam = allParams.first { it.name.asString() == PARAM_REAL_SERVICE }
    val fakeServiceParam = allParams.first { it.name.asString() == PARAM_FAKE_SERVICE }
    val isFakeModeParam = allParams.first { it.name.asString() == PARAM_IS_FAKE_MODE }

    val irBuilder = irBuilderFor(declaration)

    declaration.body =
      irBuilder.irBlockBody {
        +irReturn(
          irIfThenElse(
            declaration.returnType,
            irGet(isFakeModeParam),
            irGet(fakeServiceParam),
            irGet(realServiceParam),
          )
        )
      }
  }

  // -- Helpers --

  private fun irBuilderFor(declaration: IrSimpleFunction) =
    DeclarationIrBuilder(
      pluginContext,
      declaration.symbol,
      declaration.startOffset,
      declaration.endOffset,
    )

  /**
   * Build the `serviceCreator.create(ServiceType::class.java)` call expression. Returns null if
   * required symbols can't be resolved.
   */
  private fun buildServiceCreatorCall(
    declaration: IrSimpleFunction,
    serviceCreatorParam: org.jetbrains.kotlin.ir.declarations.IrValueParameter,
  ): org.jetbrains.kotlin.ir.expressions.IrExpression? {
    val serviceType = declaration.returnType
    val serviceClassSymbol =
      (serviceType as? IrSimpleType)?.classOrNull ?: return null

    val serviceCreatorClassSymbol =
      pluginContext.referenceClass(ClassIds.SERVICE_CREATOR) ?: return null
    val createFun =
      serviceCreatorClassSymbol.owner.declarations
        .filterIsInstance<IrSimpleFunction>()
        .singleOrNull { it.name.asString() == "create" } ?: return null

    val javaPropertySymbol =
      pluginContext
        .referenceProperties(CallableId(FqName("kotlin.jvm"), Name.identifier("java")))
        .firstOrNull() ?: return null
    val javaGetter = javaPropertySymbol.owner.getter?.symbol ?: return null

    val irBuilder = irBuilderFor(declaration)

    // ServiceType::class
    val kClassType = pluginContext.irBuiltIns.kClassClass.typeWith(serviceType)
    val classRef =
      IrClassReferenceImpl(
        UNDEFINED_OFFSET,
        UNDEFINED_OFFSET,
        kClassType,
        serviceClassSymbol,
        serviceClassSymbol.defaultType,
      )

    // ServiceType::class.java
    val javaClassExpr = irBuilder.irCall(javaGetter).apply { arguments[0] = classRef }

    // serviceCreator.create(ServiceType::class.java)
    return irBuilder.irCall(createFun.symbol).apply {
      arguments[0] = irBuilder.irGet(serviceCreatorParam)
      typeArguments[0] = serviceType
      arguments[1] = javaClassExpr
    }
  }

  companion object {
    // Parameter names forming the contract between FIR generation and IR body generation.
    private const val PARAM_SERVICE_CREATOR = "serviceCreator"
    private const val PARAM_IS_FAKE_MODE = "isFakeMode"
    private const val PARAM_REAL_SERVICE = "realService"
    private const val PARAM_FAKE_SERVICE = "fakeService"
  }
}
