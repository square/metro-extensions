package com.squareup.metro.extensions.scoped

import com.fueledbycaffeine.autoservice.AutoService
import dev.zacsweers.metro.compiler.MetroOptions
import dev.zacsweers.metro.compiler.api.fir.MetroContributionExtension
import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.fir.declarations.toAnnotationClassIdSafe
import org.jetbrains.kotlin.fir.expressions.FirAnnotationCall
import org.jetbrains.kotlin.fir.expressions.FirGetClassCall
import org.jetbrains.kotlin.fir.expressions.FirPropertyAccessExpression
import org.jetbrains.kotlin.fir.expressions.FirResolvedQualifier
import org.jetbrains.kotlin.fir.extensions.FirDeclarationPredicateRegistrar
import org.jetbrains.kotlin.fir.extensions.predicateBasedProvider
import org.jetbrains.kotlin.fir.references.FirResolvedNamedReference
import org.jetbrains.kotlin.fir.resolve.defaultType
import org.jetbrains.kotlin.fir.resolve.providers.symbolProvider
import org.jetbrains.kotlin.fir.scopes.getSingleClassifier
import org.jetbrains.kotlin.fir.scopes.impl.declaredMemberScope
import org.jetbrains.kotlin.fir.symbols.impl.FirClassLikeSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirRegularClassSymbol
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.FqName

/**
 * Implements [MetroContributionExtension] to tell Metro's `ContributedInterfaceSupertypeGenerator`
 * about contributions from our generated `MultibindingScopedContribution` interfaces.
 *
 * This is necessary because Metro's predicate-based provider only sees source declarations and
 * declarations generated by generators that registered the predicate for `@ContributesTo`. Our
 * `MultibindingScopedContribution` is generated by [ContributesMultibindingScopedFir] (which
 * registered a predicate for `@ContributesMultibindingScoped`), so Metro's in-compilation discovery
 * doesn't see it.
 *
 * By implementing this extension, we bridge the gap: when Metro asks "what contributions exist for
 * scope X?", we find classes annotated with `@ContributesMultibindingScoped(X::class)`, compute the
 * ClassId of the `MetroContribution` nested class that Metro will generate inside our
 * `MultibindingScopedContribution`, and return it as a contribution type.
 */
public class ContributesMultibindingScopedMetroExtension(private val session: FirSession) :
  MetroContributionExtension {

  private val predicate = ContributesMultibindingScopedIds.PREDICATE

  /** Classes annotated with @ContributesMultibindingScoped in this compilation. */
  private val annotatedClasses by lazy {
    session.predicateBasedProvider
      .getSymbolsByPredicate(predicate)
      .filterIsInstance<FirRegularClassSymbol>()
      .toList()
  }

  override fun FirDeclarationPredicateRegistrar.registerPredicates() {
    register(predicate)
  }

  override fun getContributions(
    scopeClassId: ClassId
  ): List<MetroContributionExtension.Contribution> {
    return annotatedClasses.mapNotNull { parentSymbol ->
      // Extract the scope from @ContributesMultibindingScoped(SomeScope::class)
      val annotationScopeClassId = extractScopeClassId(parentSymbol) ?: return@mapNotNull null

      // Only provide contributions for the requested scope
      if (annotationScopeClassId != scopeClassId) return@mapNotNull null

      // The generated MultibindingScopedContribution is a nested class of the annotated class
      val contributionInterfaceClassId =
        parentSymbol.classId.createNestedClassId(
          ContributesMultibindingScopedIds.NESTED_INTERFACE_NAME
        )

      // Look up the MultibindingScopedContribution symbol. This triggers our FIR generator
      // to lazily create it if it hasn't been created yet.
      val contributionSymbol =
        session.symbolProvider.getClassLikeSymbolByClassId(contributionInterfaceClassId)
          as? FirRegularClassSymbol ?: return@mapNotNull null

      // Access the declared member scope and query classifier names. This triggers the FIR
      // framework to call getNestedClassifiersNames on the owning generator (the composite),
      // which delegates to Metro's ContributionsFirGenerator. Metro then returns the
      // MetroContribution name (e.g., MetroContributionToKotlinunitdHiVAhs).
      // Without this step, Metro's FIR generator is never asked to generate the nested class,
      // and the symbol provider can't find it.
      val scope = contributionSymbol.declaredMemberScope(session, memberRequiredPhase = null)
      val metroContributionName =
        scope.getClassifierNames().firstOrNull { it.identifier.startsWith("MetroContributionTo") }
          ?: return@mapNotNull null

      // Now that the MetroContribution name is known (and the FIR generator has been triggered),
      // look up the actual symbol. getSingleClassifier triggers generateNestedClassLikeDeclaration
      // which creates the actual class.
      val metroContributionSymbol =
        scope.getSingleClassifier(metroContributionName) as? FirRegularClassSymbol
          ?: return@mapNotNull null

      MetroContributionExtension.Contribution(
        supertype = metroContributionSymbol.defaultType(),
        replaces = emptyList(),
        // Use the annotated class's ClassId (not the nested MultibindingScopedContribution)
        // so that Metro's replacement/exclusion logic can connect
        // @ContributesBinding(replaces = [Service1::class]) to this contribution.
        // Metro resolves originToContributions[replacedClassId] to find contributions to remove.
        originClassId = parentSymbol.classId,
      )
    }
  }

  /**
   * Extracts the scope ClassId from @ContributesMultibindingScoped(SomeScope::class).
   *
   * At the COMPILER_REQUIRED_ANNOTATIONS phase (when this is called), annotation arguments may not
   * be fully resolved. The inner argument of `SomeScope::class` may be:
   * - [FirResolvedQualifier] (fully resolved) - extract classId directly
   * - [FirPropertyAccessExpression] (partially resolved) - extract from the resolved reference
   */
  private fun extractScopeClassId(classSymbol: FirRegularClassSymbol): ClassId? {
    val annotation =
      classSymbol.resolvedCompilerAnnotationsWithClassIds.firstOrNull { ann ->
        ann.toAnnotationClassIdSafe(session) ==
          ContributesMultibindingScopedIds.CONTRIBUTES_MULTIBINDING_SCOPED_CLASS_ID
      } ?: return null

    val annotationCall = annotation as? FirAnnotationCall ?: return null
    val firstArg = annotationCall.argumentList.arguments.firstOrNull() ?: return null

    // The argument is SomeScope::class, which is a FirGetClassCall
    val getClassCall = firstArg as? FirGetClassCall ?: return null
    val innerArg = getClassCall.argumentList.arguments.firstOrNull() ?: return null

    return when (innerArg) {
      is FirResolvedQualifier -> innerArg.classId
      is FirPropertyAccessExpression -> {
        val ref = innerArg.calleeReference
        if (ref is FirResolvedNamedReference && ref.resolvedSymbol is FirClassLikeSymbol<*>) {
          (ref.resolvedSymbol as FirClassLikeSymbol<*>).classId
        } else {
          // Fallback: try to resolve a simple name in kotlin package (handles Unit::class etc.)
          val name = ref.name
          session.symbolProvider
            .getClassLikeSymbolByClassId(ClassId(FqName("kotlin"), name))
            ?.classId
        }
      }
      else -> null
    }
  }

  @AutoService(MetroContributionExtension.Factory::class)
  public class Factory : MetroContributionExtension.Factory {
    override fun create(session: FirSession, options: MetroOptions): MetroContributionExtension {
      return ContributesMultibindingScopedMetroExtension(session)
    }
  }
}
