@file:Suppress("INVISIBLE_MEMBER", "INVISIBLE_REFERENCE")

package com.squareup.metro.extensions.fir.metro

import com.squareup.metro.extensions.fir.createHintFunction
import com.squareup.metro.extensions.fir.extractScopeClassId
import com.squareup.metro.extensions.robot.ContributesRobotIds
import com.squareup.metro.extensions.scoped.ContributesMultibindingScopedIds
import dev.zacsweers.metro.compiler.fir.Keys
import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.fir.extensions.ExperimentalTopLevelDeclarationsGenerationApi
import org.jetbrains.kotlin.fir.extensions.FirDeclarationGenerationExtension
import org.jetbrains.kotlin.fir.extensions.FirDeclarationPredicateRegistrar
import org.jetbrains.kotlin.fir.extensions.MemberGenerationContext
import org.jetbrains.kotlin.fir.extensions.predicate.LookupPredicate
import org.jetbrains.kotlin.fir.extensions.predicateBasedProvider
import org.jetbrains.kotlin.fir.symbols.impl.ConeClassLikeLookupTagImpl
import org.jetbrains.kotlin.fir.symbols.impl.FirNamedFunctionSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirRegularClassSymbol
import org.jetbrains.kotlin.fir.types.impl.ConeClassLikeTypeImpl
import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name

/**
 * Generates contribution hint functions in the `metro.hints` package for plugin-generated
 * `@ContributesTo` classes.
 *
 * Metro's own `ContributionHintFirGenerator` uses `predicateBasedProvider` to discover
 * `@ContributesTo` classes, which doesn't find classes generated by external
 * [MetroFirDeclarationGenerationExtension][dev.zacsweers.metro.compiler.api.fir.MetroFirDeclarationGenerationExtension]
 * plugins. This generator fills that gap by producing identical hint functions for our generated
 * `RobotContribution` and `MultibindingScopedContribution` interfaces.
 *
 * The generated functions use Metro's `Keys.ContributionHint` origin so that Metro's IR transformer
 * recognizes them and fills in stub bodies.
 */
internal class ContributionHintFirGenerator(session: FirSession) :
  FirDeclarationGenerationExtension(session) {

  private data class ContributionInfo(
    val nestedInterfaceClassId: ClassId,
    val scopeClassId: ClassId,
  )

  private val contributions: Map<CallableId, List<ContributionInfo>> by lazy {
    buildContributionsMap()
  }

  override fun FirDeclarationPredicateRegistrar.registerPredicates() {
    register(ContributesRobotIds.PREDICATE)
    register(ContributesMultibindingScopedIds.PREDICATE)
  }

  override fun hasPackage(packageFqName: FqName): Boolean {
    return packageFqName == METRO_HINTS_PACKAGE
  }

  @ExperimentalTopLevelDeclarationsGenerationApi
  override fun getTopLevelCallableIds(): Set<CallableId> {
    return contributions.keys
  }

  @OptIn(ExperimentalTopLevelDeclarationsGenerationApi::class)
  override fun generateFunctions(
    callableId: CallableId,
    context: MemberGenerationContext?,
  ): List<FirNamedFunctionSymbol> {
    val infos = contributions[callableId] ?: return emptyList()
    return infos.map { info ->
      val containingFileName = hintFileName(info.nestedInterfaceClassId, callableId.callableName)
      val contributedType =
        ConeClassLikeTypeImpl(
          ConeClassLikeLookupTagImpl(info.nestedInterfaceClassId),
          emptyArray(),
          isMarkedNullable = false,
        )
      createHintFunction(
        Keys.ContributionHint,
        callableId,
        session.builtinTypes.unitType.coneType,
        containingFileName,
      ) {
        valueParameter(CONTRIBUTED, contributedType)
      }
    }
  }

  private fun buildContributionsMap(): Map<CallableId, List<ContributionInfo>> {
    val result = mutableMapOf<CallableId, MutableList<ContributionInfo>>()

    collectContributions(
      ContributesRobotIds.PREDICATE,
      ContributesRobotIds.CONTRIBUTES_ROBOT_CLASS_ID,
      ContributesRobotIds.NESTED_INTERFACE_NAME,
      result,
    )
    collectContributions(
      ContributesMultibindingScopedIds.PREDICATE,
      ContributesMultibindingScopedIds.CONTRIBUTES_MULTIBINDING_SCOPED_CLASS_ID,
      ContributesMultibindingScopedIds.NESTED_INTERFACE_NAME,
      result,
    )

    return result
  }

  private fun collectContributions(
    predicate: LookupPredicate,
    annotationClassId: ClassId,
    nestedInterfaceName: Name,
    result: MutableMap<CallableId, MutableList<ContributionInfo>>,
  ) {
    for (symbol in session.predicateBasedProvider.getSymbolsByPredicate(predicate)) {
      val classSymbol = symbol as? FirRegularClassSymbol ?: continue
      val scopeClassId = extractScopeClassId(classSymbol, annotationClassId, session) ?: continue
      val nestedInterfaceClassId = classSymbol.classId.createNestedClassId(nestedInterfaceName)
      val hintFunctionName = scopeHintFunctionName(scopeClassId)
      val callableId = CallableId(METRO_HINTS_PACKAGE, hintFunctionName)
      result
        .getOrPut(callableId) { mutableListOf() }
        .add(ContributionInfo(nestedInterfaceClassId, scopeClassId))
    }
  }

  companion object {
    private val METRO_HINTS_PACKAGE = FqName("metro.hints")
    private val CONTRIBUTED = Name.identifier("contributed")

    /** Equivalent to Metro's `ClassId.scopeHintFunctionName()`. */
    private fun scopeHintFunctionName(scopeClassId: ClassId): Name {
      return Name.identifier(
        scopeClassId.relativeClassName.pathSegments().joinToString("_") { it.asString() }
      )
    }

    /** Equivalent to Metro's `HintGenerator.hintFileName()`. */
    private fun hintFileName(sourceClassId: ClassId, hintName: Name): String {
      val fileNameWithoutExtension =
        sequence {
            yieldAll(sourceClassId.packageFqName.pathSegments())
            yield(
              Name.identifier(
                sourceClassId.relativeClassName.pathSegments().joinToString("") {
                  it.asString().replaceFirstChar { c -> c.uppercase() }
                }
              )
            )
            yield(hintName)
          }
          .joinToString("") { it.asString().replaceFirstChar { c -> c.uppercase() } }
          .replaceFirstChar { it.lowercase() }
      return "$fileNameWithoutExtension.kt"
    }
  }
}
