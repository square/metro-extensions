package com.squareup.metro.extensions.service

import com.fueledbycaffeine.autoservice.AutoService
import com.squareup.metro.extensions.ArgNames
import com.squareup.metro.extensions.fir.extractClassIdsFromArrayArg
import com.squareup.metro.extensions.fir.extractScopeClassId
import com.squareup.metro.extensions.fir.findAnnotation
import dev.zacsweers.metro.compiler.MetroOptions
import dev.zacsweers.metro.compiler.api.fir.MetroContributionExtension
import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.fir.extensions.FirDeclarationPredicateRegistrar
import org.jetbrains.kotlin.fir.extensions.predicateBasedProvider
import org.jetbrains.kotlin.fir.resolve.defaultType
import org.jetbrains.kotlin.fir.resolve.providers.symbolProvider
import org.jetbrains.kotlin.fir.scopes.getSingleClassifier
import org.jetbrains.kotlin.fir.scopes.impl.declaredMemberScope
import org.jetbrains.kotlin.fir.symbols.impl.FirRegularClassSymbol
import org.jetbrains.kotlin.name.ClassId

/**
 * Implements [MetroContributionExtension] to tell Metro's `ContributedInterfaceSupertypeGenerator`
 * about contributions from our generated `ServiceContribution` interfaces.
 *
 * This is necessary because Metro's predicate-based provider only discovers source declarations and
 * declarations generated by generators that registered the `@ContributesTo` predicate. Our
 * `ServiceContribution` is generated by [ContributesServiceFir] (which registers a predicate for
 * `@ContributesService`), so Metro's in-compilation discovery doesn't see it.
 *
 * When a fake service uses `replaces = [RealService::class]`, this extension also provides
 * replacement metadata so Metro removes the real service's contribution from the graph.
 */
public class ContributesServiceMetroExtension(private val session: FirSession) :
  MetroContributionExtension {

  private val predicate = ContributesServiceIds.PREDICATE

  /** All in-compilation classes annotated with `@ContributesService`. */
  private val annotatedClasses by lazy {
    session.predicateBasedProvider
      .getSymbolsByPredicate(predicate)
      .filterIsInstance<FirRegularClassSymbol>()
      .toList()
  }

  override fun FirDeclarationPredicateRegistrar.registerPredicates() {
    register(predicate)
  }

  override fun getContributions(
    scopeClassId: ClassId
  ): List<MetroContributionExtension.Contribution> {
    return annotatedClasses.mapNotNull { parentSymbol ->
      val annotationScopeClassId =
        extractScopeClassId(
          parentSymbol,
          ContributesServiceIds.CONTRIBUTES_SERVICE_CLASS_ID,
          session,
        ) ?: return@mapNotNull null

      if (annotationScopeClassId != scopeClassId) return@mapNotNull null

      val contributionInterfaceClassId =
        parentSymbol.classId.createNestedClassId(ContributesServiceIds.NESTED_INTERFACE_NAME)

      val contributionSymbol =
        session.symbolProvider.getClassLikeSymbolByClassId(contributionInterfaceClassId)
          as? FirRegularClassSymbol ?: return@mapNotNull null

      // Access the declared member scope to trigger Metro's FIR generator, which creates the
      // MetroContribution nested class inside our ServiceContribution. Without this, Metro
      // wouldn't see our contribution.
      val scope = contributionSymbol.declaredMemberScope(session, memberRequiredPhase = null)
      val metroContributionName =
        scope.getClassifierNames().firstOrNull { it.identifier.startsWith("MetroContributionTo") }
          ?: return@mapNotNull null

      val metroContributionSymbol =
        scope.getSingleClassifier(metroContributionName) as? FirRegularClassSymbol
          ?: return@mapNotNull null

      val replacesClassIds = buildReplacesClassIds(parentSymbol)

      MetroContributionExtension.Contribution(
        supertype = metroContributionSymbol.defaultType(),
        replaces = replacesClassIds,
        originClassId = parentSymbol.classId,
      )
    }
  }

  /**
   * Build the replaces ClassId list for the contribution. Includes both the origin ClassId (e.g.,
   * `MyService`) and its `ServiceContribution` ClassId because Metro keys contributions differently
   * depending on how they were discovered:
   * - **In-compilation** (via MetroContributionExtension): keyed by `originClassId`
   * - **Cross-module** (via serialized hints): keyed by `ServiceContribution` ClassId
   */
  private fun buildReplacesClassIds(parentSymbol: FirRegularClassSymbol): List<ClassId> {
    val rawReplacesClassIds = extractReplacesClassIds(parentSymbol)
    return rawReplacesClassIds.flatMap {
      listOf(it, it.createNestedClassId(ContributesServiceIds.NESTED_INTERFACE_NAME))
    }
  }

  private fun extractReplacesClassIds(parentSymbol: FirRegularClassSymbol): List<ClassId> {
    val annotation =
      findAnnotation(parentSymbol, ContributesServiceIds.CONTRIBUTES_SERVICE_CLASS_ID, session)
        ?: return emptyList()
    return extractClassIdsFromArrayArg(
      annotation,
      ArgNames.REPLACES,
      session,
      fallbackPackage = parentSymbol.classId.packageFqName,
      ownerSymbol = parentSymbol,
    )
  }

  @AutoService(MetroContributionExtension.Factory::class)
  public class Factory : MetroContributionExtension.Factory {
    override fun create(session: FirSession, options: MetroOptions): MetroContributionExtension {
      return ContributesServiceMetroExtension(session)
    }
  }
}
