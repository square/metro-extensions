package com.squareup.metro.extensions.service

import com.fueledbycaffeine.autoservice.AutoService
import com.squareup.metro.extensions.fir.extractScopeClassId
import dev.zacsweers.metro.compiler.MetroOptions
import dev.zacsweers.metro.compiler.api.fir.MetroContributionExtension
import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.fir.extensions.FirDeclarationPredicateRegistrar
import org.jetbrains.kotlin.fir.extensions.predicateBasedProvider
import org.jetbrains.kotlin.fir.resolve.defaultType
import org.jetbrains.kotlin.fir.resolve.providers.symbolProvider
import org.jetbrains.kotlin.fir.scopes.getSingleClassifier
import org.jetbrains.kotlin.fir.scopes.impl.declaredMemberScope
import org.jetbrains.kotlin.fir.symbols.impl.FirRegularClassSymbol
import org.jetbrains.kotlin.name.ClassId

/**
 * Implements [MetroContributionExtension] to tell Metro's `ContributedInterfaceSupertypeGenerator`
 * about contributions from our generated `ServiceContribution` interfaces.
 *
 * This is necessary because Metro's predicate-based provider only sees source declarations and
 * declarations generated by generators that registered the predicate for `@ContributesTo`. Our
 * `ServiceContribution` is generated by [ContributesServiceFir] (which registered a predicate for
 * `@ContributesService`), so Metro's in-compilation discovery doesn't see it.
 */
public class ContributesServiceMetroExtension(private val session: FirSession) :
  MetroContributionExtension {

  private val predicate = ContributesServiceIds.PREDICATE

  private val annotatedClasses by lazy {
    session.predicateBasedProvider
      .getSymbolsByPredicate(predicate)
      .filterIsInstance<FirRegularClassSymbol>()
      .toList()
  }

  override fun FirDeclarationPredicateRegistrar.registerPredicates() {
    register(predicate)
  }

  override fun getContributions(
    scopeClassId: ClassId
  ): List<MetroContributionExtension.Contribution> {
    return annotatedClasses.mapNotNull { parentSymbol ->
      val annotationScopeClassId =
        extractScopeClassId(
          parentSymbol,
          ContributesServiceIds.CONTRIBUTES_SERVICE_CLASS_ID,
          session,
        ) ?: return@mapNotNull null

      if (annotationScopeClassId != scopeClassId) return@mapNotNull null

      val contributionInterfaceClassId =
        parentSymbol.classId.createNestedClassId(ContributesServiceIds.NESTED_INTERFACE_NAME)

      val contributionSymbol =
        session.symbolProvider.getClassLikeSymbolByClassId(contributionInterfaceClassId)
          as? FirRegularClassSymbol ?: return@mapNotNull null

      // Trigger Metro's FIR generator to create the MetroContribution nested class.
      val scope = contributionSymbol.declaredMemberScope(session, memberRequiredPhase = null)
      val metroContributionName =
        scope.getClassifierNames().firstOrNull { it.identifier.startsWith("MetroContributionTo") }
          ?: return@mapNotNull null

      val metroContributionSymbol =
        scope.getSingleClassifier(metroContributionName) as? FirRegularClassSymbol
          ?: return@mapNotNull null

      MetroContributionExtension.Contribution(
        supertype = metroContributionSymbol.defaultType(),
        replaces = emptyList(),
        originClassId = parentSymbol.classId,
      )
    }
  }

  @AutoService(MetroContributionExtension.Factory::class)
  public class Factory : MetroContributionExtension.Factory {
    override fun create(session: FirSession, options: MetroOptions): MetroContributionExtension {
      return ContributesServiceMetroExtension(session)
    }
  }
}
