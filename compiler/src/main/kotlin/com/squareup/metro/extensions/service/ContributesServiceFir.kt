package com.squareup.metro.extensions.service

import com.fueledbycaffeine.autoservice.AutoService
import com.squareup.metro.extensions.ArgNames
import com.squareup.metro.extensions.ClassIds
import com.squareup.metro.extensions.Keys.ContributesServiceGeneratorKey
import com.squareup.metro.extensions.fir.buildAnnotationWithScope
import com.squareup.metro.extensions.fir.extractScopeArgument
import com.squareup.metro.extensions.fir.hasAnnotation
import dev.zacsweers.metro.compiler.MetroOptions
import dev.zacsweers.metro.compiler.api.fir.MetroFirDeclarationGenerationExtension
import org.jetbrains.kotlin.descriptors.ClassKind
import org.jetbrains.kotlin.descriptors.Modality
import org.jetbrains.kotlin.descriptors.Visibilities
import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.fir.declarations.DirectDeclarationsAccess
import org.jetbrains.kotlin.fir.declarations.FirResolvePhase
import org.jetbrains.kotlin.fir.declarations.FirSimpleFunction
import org.jetbrains.kotlin.fir.declarations.builder.buildRegularClass
import org.jetbrains.kotlin.fir.declarations.builder.buildSimpleFunction
import org.jetbrains.kotlin.fir.declarations.builder.buildValueParameter
import org.jetbrains.kotlin.fir.declarations.impl.FirResolvedDeclarationStatusImpl
import org.jetbrains.kotlin.fir.declarations.origin
import org.jetbrains.kotlin.fir.declarations.toAnnotationClassIdSafe
import org.jetbrains.kotlin.fir.expressions.FirAnnotationCall
import org.jetbrains.kotlin.fir.expressions.FirAnnotationResolvePhase
import org.jetbrains.kotlin.fir.expressions.FirExpression
import org.jetbrains.kotlin.fir.expressions.builder.buildAnnotation
import org.jetbrains.kotlin.fir.expressions.builder.buildAnnotationArgumentMapping
import org.jetbrains.kotlin.fir.expressions.builder.buildAnnotationCall
import org.jetbrains.kotlin.fir.expressions.buildResolvedArgumentList
import org.jetbrains.kotlin.fir.extensions.FirDeclarationPredicateRegistrar
import org.jetbrains.kotlin.fir.extensions.NestedClassGenerationContext
import org.jetbrains.kotlin.fir.moduleData
import org.jetbrains.kotlin.fir.references.builder.buildResolvedNamedReference
import org.jetbrains.kotlin.fir.resolve.defaultType
import org.jetbrains.kotlin.fir.resolve.providers.symbolProvider
import org.jetbrains.kotlin.fir.scopes.kotlinScopeProvider
import org.jetbrains.kotlin.fir.symbols.FirBasedSymbol
import org.jetbrains.kotlin.fir.symbols.SymbolInternals
import org.jetbrains.kotlin.fir.symbols.impl.ConeClassLikeLookupTagImpl
import org.jetbrains.kotlin.fir.symbols.impl.FirClassLikeSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirClassSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirConstructorSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirNamedFunctionSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirRegularClassSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirValueParameterSymbol
import org.jetbrains.kotlin.fir.toEffectiveVisibility
import org.jetbrains.kotlin.fir.toFirResolvedTypeRef
import org.jetbrains.kotlin.fir.types.impl.ConeClassLikeTypeImpl
import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.Name

/**
 * Generates a nested `ServiceContribution` interface for classes annotated with
 * `@ContributesService`.
 *
 * For a real service like:
 * ```
 * @ContributesService(SomeScope::class)
 * @SomeQualifier
 * interface MyService
 * ```
 *
 * This generator produces:
 * ```
 * @ContributesTo(SomeScope::class)
 * interface ServiceContribution {
 *   @Provides @SingleIn(SomeScope::class)
 *   fun provideMyService(
 *     @SomeQualifier serviceCreator: ServiceCreator,
 *     @FakeMode isFakeMode: Boolean,
 *   ): MyService
 * }
 * ```
 *
 * The function is added directly to the class's declarations list (rather than through
 * `getCallableNamesForClass`/`generateFunctions`) so Metro can see it when deciding what nested
 * classes to generate (e.g., ProvidesFactory).
 *
 * The function body is generated by [ContributesServiceIrExtension] in the IR phase.
 */
public class ContributesServiceFir(session: FirSession) :
  MetroFirDeclarationGenerationExtension(session) {

  override fun FirDeclarationPredicateRegistrar.registerPredicates() {
    register(ContributesServiceIds.PREDICATE)
  }

  override fun getNestedClassifiersNames(
    classSymbol: FirClassSymbol<*>,
    context: NestedClassGenerationContext,
  ): Set<Name> {
    if (
      hasAnnotation(
        classSymbol,
        ContributesServiceIds.CONTRIBUTES_SERVICE_CLASS_ID,
        session,
      )
    ) {
      return setOf(ContributesServiceIds.NESTED_INTERFACE_NAME)
    }
    return emptySet()
  }

  override fun generateNestedClassLikeDeclaration(
    owner: FirClassSymbol<*>,
    name: Name,
    context: NestedClassGenerationContext,
  ): FirClassLikeSymbol<*>? {
    if (name != ContributesServiceIds.NESTED_INTERFACE_NAME) return null
    if (
      !hasAnnotation(
        owner,
        ContributesServiceIds.CONTRIBUTES_SERVICE_CLASS_ID,
        session,
      )
    )
      return null
    val scopeArg =
      extractScopeArgument(
        owner,
        ContributesServiceIds.CONTRIBUTES_SERVICE_CLASS_ID,
        session,
      ) ?: return null

    val qualifierAnnotation = findQualifierAnnotation(owner)

    val nestedClassId = owner.classId.createNestedClassId(name)
    val classSymbol = FirRegularClassSymbol(nestedClassId)

    // Build the @Provides function and add it directly to the class declarations.
    // This makes it visible to Metro's getNestedClassifiersNames (which checks for @Provides
    // functions to decide whether to generate ProvidesFactory).
    val providesFunction =
      buildProvidesFunction(nestedClassId, owner, scopeArg, qualifierAnnotation)

    val klass = buildRegularClass {
      resolvePhase = FirResolvePhase.BODY_RESOLVE
      moduleData = session.moduleData
      origin = ContributesServiceGeneratorKey.origin
      source = owner.source
      classKind = ClassKind.INTERFACE
      scopeProvider = session.kotlinScopeProvider
      this.name = nestedClassId.shortClassName
      symbol = classSymbol
      status =
        FirResolvedDeclarationStatusImpl(
          Visibilities.Public,
          Modality.ABSTRACT,
          Visibilities.Public.toEffectiveVisibility(owner, forClass = true),
        )
      superTypeRefs += session.builtinTypes.anyType
      annotations += buildAnnotationWithScope(ClassIds.CONTRIBUTES_TO, ArgNames.SCOPE, scopeArg)
      // Add the function directly to the class declarations
      declarations += providesFunction
    }

    return klass.symbol
  }

  private fun buildProvidesFunction(
    classId: ClassId,
    outerOwner: FirClassSymbol<*>,
    scopeArg: FirExpression,
    qualifierAnnotation: org.jetbrains.kotlin.fir.expressions.FirAnnotation?,
  ): FirSimpleFunction {
    val outerClassId = outerOwner.classId
    val functionName = "provide${outerClassId.shortClassName.identifier}"
    val callableId = CallableId(classId, Name.identifier(functionName))

    val outerClassType = outerOwner.defaultType()
    val serviceCreatorType =
      ConeClassLikeTypeImpl(
        ConeClassLikeLookupTagImpl(ClassIds.SERVICE_CREATOR),
        emptyArray(),
        isMarkedNullable = false,
      )
    // Build the dispatch receiver type manually since classSymbol isn't bound to FIR yet
    val dispatchType =
      ConeClassLikeTypeImpl(
        ConeClassLikeLookupTagImpl(classId),
        emptyArray(),
        isMarkedNullable = false,
      )

    val functionSymbol = FirNamedFunctionSymbol(callableId)

    return buildSimpleFunction {
      resolvePhase = FirResolvePhase.BODY_RESOLVE
      moduleData = session.moduleData
      origin = ContributesServiceGeneratorKey.origin
      symbol = functionSymbol
      name = callableId.callableName
      returnTypeRef = outerClassType.toFirResolvedTypeRef()
      dispatchReceiverType = dispatchType
      status =
        FirResolvedDeclarationStatusImpl(
          Visibilities.Public,
          Modality.OPEN,
          Visibilities.Public.toEffectiveVisibility(outerOwner, forClass = true),
        )

      // Parameter: @Qualifier serviceCreator: ServiceCreator
      this.valueParameters += buildValueParameter {
        resolvePhase = FirResolvePhase.BODY_RESOLVE
        moduleData = session.moduleData
        origin = ContributesServiceGeneratorKey.origin
        returnTypeRef = serviceCreatorType.toFirResolvedTypeRef()
        this.name = Name.identifier("serviceCreator")
        symbol = FirValueParameterSymbol()
        containingDeclarationSymbol = functionSymbol
        if (qualifierAnnotation != null) {
          annotations += qualifierAnnotation
        }
      }

      // Parameter: @FakeMode isFakeMode: Boolean
      this.valueParameters += buildValueParameter {
        resolvePhase = FirResolvePhase.BODY_RESOLVE
        moduleData = session.moduleData
        origin = ContributesServiceGeneratorKey.origin
        returnTypeRef = session.builtinTypes.booleanType
        this.name = Name.identifier("isFakeMode")
        symbol = FirValueParameterSymbol()
        containingDeclarationSymbol = functionSymbol
        annotations += buildSimpleAnnotation(ClassIds.FAKE_MODE)
      }

      annotations += buildSimpleAnnotationCall(ClassIds.PROVIDES, functionSymbol)
      annotations +=
        buildAnnotationCallWithScope(ClassIds.SINGLE_IN, ArgNames.VALUE, scopeArg, functionSymbol)
    }
  }

  private fun findQualifierAnnotation(
    classSymbol: FirClassSymbol<*>,
  ): org.jetbrains.kotlin.fir.expressions.FirAnnotation? {
    for (annotation in classSymbol.resolvedAnnotationsWithArguments) {
      val annotationClassId = annotation.toAnnotationClassIdSafe(session) ?: continue
      if (annotationClassId == ContributesServiceIds.CONTRIBUTES_SERVICE_CLASS_ID) continue
      val annotationSymbol =
        session.symbolProvider.getClassLikeSymbolByClassId(annotationClassId)
          as? FirClassSymbol<*> ?: continue
      val isQualifier =
        annotationSymbol.resolvedCompilerAnnotationsWithClassIds.any {
          it.toAnnotationClassIdSafe(session) in ClassIds.QUALIFIER_CLASS_IDS
        }
      if (isQualifier) return annotation
    }
    return null
  }

  private fun buildSimpleAnnotation(
    classId: ClassId,
  ): org.jetbrains.kotlin.fir.expressions.FirAnnotation {
    val annotationType =
      ConeClassLikeTypeImpl(
        ConeClassLikeLookupTagImpl(classId),
        emptyArray(),
        isMarkedNullable = false,
      )
    return buildAnnotation {
      annotationTypeRef = annotationType.toFirResolvedTypeRef()
      argumentMapping = buildAnnotationArgumentMapping()
    }
  }

  /**
   * Build an annotation as [FirAnnotationCall] so Metro recognizes it. Metro's `metroAnnotations()`
   * checks `annotation !is FirAnnotationCall` and skips plain [FirAnnotation] instances.
   */
  @OptIn(DirectDeclarationsAccess::class)
  private fun buildSimpleAnnotationCall(
    classId: ClassId,
    containingSymbol: FirBasedSymbol<*>,
  ): FirAnnotationCall {
    val annotationType =
      ConeClassLikeTypeImpl(
        ConeClassLikeLookupTagImpl(classId),
        emptyArray(),
        isMarkedNullable = false,
      )
    return buildAnnotationCall {
      annotationTypeRef = annotationType.toFirResolvedTypeRef()
      argumentMapping = buildAnnotationArgumentMapping()
      calleeReference = buildResolvedNamedReference {
        name = classId.shortClassName
        resolvedSymbol =
          session.symbolProvider.getClassLikeSymbolByClassId(classId)!!.let {
            (it as FirClassSymbol<*>)
              .declarationSymbols
              .filterIsInstance<FirConstructorSymbol>()
              .first()
          }
      }
      containingDeclarationSymbol = containingSymbol
      annotationResolvePhase = FirAnnotationResolvePhase.Types
    }
  }

  /**
   * Build an annotation with scope argument as [FirAnnotationCall].
   *
   * Uses [buildResolvedArgumentList] so the FIR-to-IR converter recognizes the arguments. The
   * converter checks `argumentList is FirResolvedArgumentList` to extract the argument mapping â€” a
   * plain `buildArgumentList` would be treated as unresolved.
   */
  @OptIn(DirectDeclarationsAccess::class, SymbolInternals::class)
  private fun buildAnnotationCallWithScope(
    classId: ClassId,
    argName: Name,
    scopeArg: FirExpression,
    containingSymbol: FirBasedSymbol<*>,
  ): FirAnnotationCall {
    val annotationType =
      ConeClassLikeTypeImpl(
        ConeClassLikeLookupTagImpl(classId),
        emptyArray(),
        isMarkedNullable = false,
      )

    // Look up the annotation constructor and its parameter
    val annotationClassSymbol = session.symbolProvider.getClassLikeSymbolByClassId(classId)!!
    val constructorSymbol =
      (annotationClassSymbol as FirClassSymbol<*>)
        .declarationSymbols
        .filterIsInstance<FirConstructorSymbol>()
        .first()
    val scopeParam = constructorSymbol.fir.valueParameters.first { it.name == argName }

    return buildAnnotationCall {
      annotationTypeRef = annotationType.toFirResolvedTypeRef()
      argumentMapping = buildAnnotationArgumentMapping { mapping[argName] = scopeArg }
      argumentList =
        buildResolvedArgumentList(original = null, mapping = linkedMapOf(scopeArg to scopeParam))
      calleeReference = buildResolvedNamedReference {
        name = classId.shortClassName
        resolvedSymbol = constructorSymbol
      }
      containingDeclarationSymbol = containingSymbol
      annotationResolvePhase = FirAnnotationResolvePhase.Types
    }
  }

  @AutoService(MetroFirDeclarationGenerationExtension.Factory::class)
  public class Factory : MetroFirDeclarationGenerationExtension.Factory {
    override fun create(
      session: FirSession,
      options: MetroOptions,
    ): MetroFirDeclarationGenerationExtension = ContributesServiceFir(session)
  }
}
