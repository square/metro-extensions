package com.squareup.metro.extensions.service

import com.fueledbycaffeine.autoservice.AutoService
import com.squareup.metro.extensions.ArgNames
import com.squareup.metro.extensions.ClassIds
import com.squareup.metro.extensions.Keys.ContributesServiceGeneratorKey
import com.squareup.metro.extensions.fir.buildAnnotationWithScope
import com.squareup.metro.extensions.fir.extractClassIdsFromArrayArg
import com.squareup.metro.extensions.fir.extractScopeArgument
import com.squareup.metro.extensions.fir.findAnnotation
import com.squareup.metro.extensions.fir.hasAnnotation
import dev.zacsweers.metro.compiler.MetroOptions
import dev.zacsweers.metro.compiler.api.fir.MetroFirDeclarationGenerationExtension
import org.jetbrains.kotlin.descriptors.ClassKind
import org.jetbrains.kotlin.descriptors.Modality
import org.jetbrains.kotlin.descriptors.Visibilities
import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.fir.declarations.DirectDeclarationsAccess
import org.jetbrains.kotlin.fir.declarations.FirResolvePhase
import org.jetbrains.kotlin.fir.declarations.FirSimpleFunction
import org.jetbrains.kotlin.fir.declarations.builder.buildRegularClass
import org.jetbrains.kotlin.fir.declarations.builder.buildSimpleFunction
import org.jetbrains.kotlin.fir.declarations.builder.buildValueParameter
import org.jetbrains.kotlin.fir.declarations.impl.FirResolvedDeclarationStatusImpl
import org.jetbrains.kotlin.fir.declarations.origin
import org.jetbrains.kotlin.fir.declarations.toAnnotationClassIdSafe
import org.jetbrains.kotlin.fir.expressions.FirAnnotationCall
import org.jetbrains.kotlin.fir.expressions.FirAnnotationResolvePhase
import org.jetbrains.kotlin.fir.expressions.FirExpression
import org.jetbrains.kotlin.fir.expressions.builder.buildArgumentList
import org.jetbrains.kotlin.fir.expressions.builder.buildArrayLiteral
import org.jetbrains.kotlin.fir.expressions.builder.buildGetClassCall
import org.jetbrains.kotlin.fir.expressions.builder.buildResolvedQualifier
import org.jetbrains.kotlin.fir.expressions.builder.buildAnnotation
import org.jetbrains.kotlin.fir.expressions.builder.buildAnnotationArgumentMapping
import org.jetbrains.kotlin.fir.expressions.builder.buildAnnotationCall
import org.jetbrains.kotlin.fir.expressions.buildResolvedArgumentList
import org.jetbrains.kotlin.fir.extensions.FirDeclarationPredicateRegistrar
import org.jetbrains.kotlin.fir.extensions.NestedClassGenerationContext
import org.jetbrains.kotlin.fir.moduleData
import org.jetbrains.kotlin.fir.references.builder.buildResolvedNamedReference
import org.jetbrains.kotlin.fir.resolve.defaultType
import org.jetbrains.kotlin.fir.resolve.providers.symbolProvider
import org.jetbrains.kotlin.fir.scopes.kotlinScopeProvider
import org.jetbrains.kotlin.fir.symbols.FirBasedSymbol
import org.jetbrains.kotlin.fir.symbols.SymbolInternals
import org.jetbrains.kotlin.fir.symbols.impl.ConeClassLikeLookupTagImpl
import org.jetbrains.kotlin.fir.symbols.impl.FirClassLikeSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirClassSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirConstructorSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirNamedFunctionSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirRegularClassSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirValueParameterSymbol
import org.jetbrains.kotlin.fir.toEffectiveVisibility
import org.jetbrains.kotlin.fir.toFirResolvedTypeRef
import org.jetbrains.kotlin.fir.types.impl.ConeClassLikeTypeImpl
import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.Name

/**
 * Generates a nested `ServiceContribution` interface for classes annotated with
 * `@ContributesService`.
 *
 * For a **real service** (no `replaces`):
 * ```
 * @ContributesTo(SomeScope::class)
 * interface ServiceContribution {
 *   @Provides @SingleIn(SomeScope::class)
 *   fun provideMyService(
 *     @SomeQualifier serviceCreator: ServiceCreator,
 *     @FakeMode isFakeMode: Boolean,
 *   ): MyService
 * }
 * ```
 *
 * For a **fake service** (`replaces = [MyService::class]`):
 * ```
 * @ContributesTo(SomeScope::class)
 * interface ServiceContribution {
 *   @Provides @SingleIn(SomeScope::class) @RealService
 *   fun provideMyService(@SomeQualifier serviceCreator: ServiceCreator): MyService
 *
 *   @Provides
 *   fun provideFakeOrRealMyService(
 *     @RealService realService: Provider<MyService>,
 *     fakeService: Provider<FakeMyService>,
 *     @FakeMode isFakeMode: Boolean,
 *   ): MyService
 * }
 * ```
 *
 * Functions are added directly to the class's declarations list (rather than through
 * `getCallableNamesForClass`/`generateFunctions`) so Metro can see them when deciding what nested
 * classes to generate (e.g., ProvidesFactory).
 *
 * Function bodies are generated by [ContributesServiceIrExtension] in the IR phase.
 */
public class ContributesServiceFir(session: FirSession) :
  MetroFirDeclarationGenerationExtension(session) {

  override fun FirDeclarationPredicateRegistrar.registerPredicates() {
    register(ContributesServiceIds.PREDICATE)
  }

  override fun getNestedClassifiersNames(
    classSymbol: FirClassSymbol<*>,
    context: NestedClassGenerationContext,
  ): Set<Name> {
    if (
      hasAnnotation(
        classSymbol,
        ContributesServiceIds.CONTRIBUTES_SERVICE_CLASS_ID,
        session,
      )
    ) {
      return setOf(ContributesServiceIds.NESTED_INTERFACE_NAME)
    }
    return emptySet()
  }

  override fun generateNestedClassLikeDeclaration(
    owner: FirClassSymbol<*>,
    name: Name,
    context: NestedClassGenerationContext,
  ): FirClassLikeSymbol<*>? {
    if (name != ContributesServiceIds.NESTED_INTERFACE_NAME) return null
    if (
      !hasAnnotation(
        owner,
        ContributesServiceIds.CONTRIBUTES_SERVICE_CLASS_ID,
        session,
      )
    )
      return null
    val scopeArg =
      extractScopeArgument(
        owner,
        ContributesServiceIds.CONTRIBUTES_SERVICE_CLASS_ID,
        session,
      ) ?: return null

    // Check if this is a fake service (has replaces)
    val replacesClassIds = extractReplacesClassIds(owner)

    val nestedClassId = owner.classId.createNestedClassId(name)
    val classSymbol = FirRegularClassSymbol(nestedClassId)

    // Build the @Provides function(s) and add directly to the class declarations.
    // This makes them visible to Metro's getNestedClassifiersNames (which checks for @Provides
    // functions to decide whether to generate ProvidesFactory).
    val providesFunctions =
      if (replacesClassIds.isNotEmpty()) {
        buildFakeServiceFunctions(nestedClassId, owner, scopeArg, replacesClassIds.first())
      } else {
        val qualifierAnnotation = findQualifierAnnotation(owner)
        listOf(buildRealServiceProvidesFunction(nestedClassId, owner, scopeArg, qualifierAnnotation))
      }

    val klass = buildRegularClass {
      resolvePhase = FirResolvePhase.BODY_RESOLVE
      moduleData = session.moduleData
      origin = ContributesServiceGeneratorKey.origin
      source = owner.source
      classKind = ClassKind.INTERFACE
      scopeProvider = session.kotlinScopeProvider
      this.name = nestedClassId.shortClassName
      symbol = classSymbol
      status =
        FirResolvedDeclarationStatusImpl(
          Visibilities.Public,
          Modality.ABSTRACT,
          Visibilities.Public.toEffectiveVisibility(owner, forClass = true),
        )
      superTypeRefs += session.builtinTypes.anyType
      if (replacesClassIds.isNotEmpty()) {
        // For fake services, include replaces in @ContributesTo so Metro handles replacement
        // both in-compilation (FIR supertypes) and cross-module (IR merger).
        annotations +=
          buildContributesToWithReplaces(scopeArg, replacesClassIds, owner)
      } else {
        annotations += buildAnnotationWithScope(ClassIds.CONTRIBUTES_TO, ArgNames.SCOPE, scopeArg)
      }
      // Add the function(s) directly to the class declarations
      for (fn in providesFunctions) {
        declarations += fn
      }
    }

    return klass.symbol
  }

  /**
   * Extract `replaces` ClassIds from the `@ContributesService` annotation.
   *
   * Uses the raw [FirAnnotationCall.argumentList] because during FIR generation, the annotation's
   * [argumentMapping][org.jetbrains.kotlin.fir.expressions.FirAnnotation.argumentMapping] may not
   * yet be populated.
   */
  /**
   * Extract `replaces` ClassIds from the `@ContributesService` annotation.
   *
   * During FIR generation, `argumentMapping` is not yet populated, so we scan the raw
   * `argumentList` for the named `replaces` argument.
   */
  private fun extractReplacesClassIds(owner: FirClassSymbol<*>): List<ClassId> {
    val annotation =
      findAnnotation(owner, ContributesServiceIds.CONTRIBUTES_SERVICE_CLASS_ID, session)
        ?: return emptyList()
    return extractClassIdsFromArrayArg(
      annotation,
      ArgNames.REPLACES,
      session,
      fallbackPackage = owner.classId.packageFqName,
    )
  }

  /**
   * Build the single `@Provides` function for a real service (no `replaces`).
   *
   * Generates: `@Provides @SingleIn(scope) fun provideXxx(@Qualifier serviceCreator, @FakeMode isFakeMode): ServiceType`
   */
  private fun buildRealServiceProvidesFunction(
    classId: ClassId,
    outerOwner: FirClassSymbol<*>,
    scopeArg: FirExpression,
    qualifierAnnotation: org.jetbrains.kotlin.fir.expressions.FirAnnotation?,
  ): FirSimpleFunction {
    val outerClassId = outerOwner.classId
    val functionName = "provide${outerClassId.shortClassName.identifier}"
    val callableId = CallableId(classId, Name.identifier(functionName))

    val outerClassType = outerOwner.defaultType()
    val serviceCreatorType =
      ConeClassLikeTypeImpl(
        ConeClassLikeLookupTagImpl(ClassIds.SERVICE_CREATOR),
        emptyArray(),
        isMarkedNullable = false,
      )
    val dispatchType =
      ConeClassLikeTypeImpl(
        ConeClassLikeLookupTagImpl(classId),
        emptyArray(),
        isMarkedNullable = false,
      )

    val functionSymbol = FirNamedFunctionSymbol(callableId)

    return buildSimpleFunction {
      resolvePhase = FirResolvePhase.BODY_RESOLVE
      moduleData = session.moduleData
      origin = ContributesServiceGeneratorKey.origin
      symbol = functionSymbol
      name = callableId.callableName
      returnTypeRef = outerClassType.toFirResolvedTypeRef()
      dispatchReceiverType = dispatchType
      status =
        FirResolvedDeclarationStatusImpl(
          Visibilities.Public,
          Modality.OPEN,
          Visibilities.Public.toEffectiveVisibility(outerOwner, forClass = true),
        )

      // Parameter: @Qualifier serviceCreator: ServiceCreator
      this.valueParameters += buildValueParameter {
        resolvePhase = FirResolvePhase.BODY_RESOLVE
        moduleData = session.moduleData
        origin = ContributesServiceGeneratorKey.origin
        returnTypeRef = serviceCreatorType.toFirResolvedTypeRef()
        this.name = Name.identifier("serviceCreator")
        symbol = FirValueParameterSymbol()
        containingDeclarationSymbol = functionSymbol
        if (qualifierAnnotation != null) {
          annotations += qualifierAnnotation
        }
      }

      // Parameter: @FakeMode isFakeMode: Boolean
      this.valueParameters += buildValueParameter {
        resolvePhase = FirResolvePhase.BODY_RESOLVE
        moduleData = session.moduleData
        origin = ContributesServiceGeneratorKey.origin
        returnTypeRef = session.builtinTypes.booleanType
        this.name = Name.identifier("isFakeMode")
        symbol = FirValueParameterSymbol()
        containingDeclarationSymbol = functionSymbol
        annotations += buildSimpleAnnotation(ClassIds.FAKE_MODE)
      }

      annotations += buildSimpleAnnotationCall(ClassIds.PROVIDES, functionSymbol)
      annotations +=
        buildAnnotationCallWithScope(ClassIds.SINGLE_IN, ArgNames.VALUE, scopeArg, functionSymbol)
    }
  }

  /**
   * Build the `@Provides` function for a fake service (has `replaces`).
   *
   * Generates a simple binding that delegates to the fake service:
   * ```
   * @Provides
   * fun provideMyServiceFromFake(fake: FakeMyService): MyService = fake
   * ```
   *
   * The fake class has `@Inject`, so Metro can construct it. The MetroContributionExtension handles
   * replacing the real service's contribution, so only this binding exists in the graph.
   */
  private fun buildFakeServiceFunctions(
    nestedClassId: ClassId,
    fakeOwner: FirClassSymbol<*>,
    scopeArg: FirExpression,
    replacedClassId: ClassId,
  ): List<FirSimpleFunction> {
    val replacedSymbol =
      session.symbolProvider.getClassLikeSymbolByClassId(replacedClassId) as? FirClassSymbol<*>
        ?: return emptyList()

    val replacedType = replacedSymbol.defaultType()
    val fakeType = fakeOwner.defaultType()

    val dispatchType =
      ConeClassLikeTypeImpl(
        ConeClassLikeLookupTagImpl(nestedClassId),
        emptyArray(),
        isMarkedNullable = false,
      )

    val replacedName = replacedClassId.shortClassName.identifier
    val functionName = "provide${replacedName}"
    val callableId = CallableId(nestedClassId, Name.identifier(functionName))
    val functionSymbol = FirNamedFunctionSymbol(callableId)

    val fn = buildSimpleFunction {
      resolvePhase = FirResolvePhase.BODY_RESOLVE
      moduleData = session.moduleData
      origin = ContributesServiceGeneratorKey.origin
      symbol = functionSymbol
      name = callableId.callableName
      // Return the REPLACED service type, not the fake type
      returnTypeRef = replacedType.toFirResolvedTypeRef()
      dispatchReceiverType = dispatchType
      status =
        FirResolvedDeclarationStatusImpl(
          Visibilities.Public,
          Modality.OPEN,
          Visibilities.Public.toEffectiveVisibility(fakeOwner, forClass = true),
        )

      // Parameter: fakeService: FakeMyService (injected via @Inject constructor)
      this.valueParameters += buildValueParameter {
        resolvePhase = FirResolvePhase.BODY_RESOLVE
        moduleData = session.moduleData
        origin = ContributesServiceGeneratorKey.origin
        returnTypeRef = fakeType.toFirResolvedTypeRef()
        this.name = Name.identifier("fakeService")
        symbol = FirValueParameterSymbol()
        containingDeclarationSymbol = functionSymbol
      }

      annotations += buildSimpleAnnotationCall(ClassIds.PROVIDES, functionSymbol)
    }

    return listOf(fn)
  }

  /**
   * Build `@ContributesTo(scope, replaces = [ReplacedClass.ServiceContribution::class])` as a
   * [FirAnnotationCall] with [buildResolvedArgumentList] so the FIR-to-IR converter properly
   * serializes both the scope and replaces arguments. This enables Metro's IR merger to read the
   * replaces argument for cross-module replacement.
   */
  @OptIn(DirectDeclarationsAccess::class, SymbolInternals::class)
  private fun buildContributesToWithReplaces(
    scopeArg: FirExpression,
    replacedClassIds: List<ClassId>,
    owner: FirClassSymbol<*>,
  ): FirAnnotationCall {
    val kClassClassId =
      ClassId(org.jetbrains.kotlin.name.FqName("kotlin.reflect"), Name.identifier("KClass"))

    // Build resolved class references for [ReplacedClass.ServiceContribution::class, ...]
    val getClassCalls = replacedClassIds.map { outerClassId ->
      val replacedId =
        outerClassId.createNestedClassId(ContributesServiceIds.NESTED_INTERFACE_NAME)
      val replacedType =
        ConeClassLikeTypeImpl(
          ConeClassLikeLookupTagImpl(replacedId),
          emptyArray(),
          isMarkedNullable = false,
        )
      val kClassType =
        ConeClassLikeTypeImpl(
          ConeClassLikeLookupTagImpl(kClassClassId),
          arrayOf(replacedType),
          isMarkedNullable = false,
        )
      buildGetClassCall {
        coneTypeOrNull = kClassType
        argumentList = buildArgumentList {
          arguments += buildResolvedQualifier {
            packageFqName = replacedId.packageFqName
            relativeClassFqName = replacedId.relativeClassName
            coneTypeOrNull = replacedType
            symbol = session.symbolProvider.getClassLikeSymbolByClassId(replacedId)
            resolvedToCompanionObject = false
          }
        }
      }
    }

    val arrayLiteral = buildArrayLiteral {
      coneTypeOrNull = session.builtinTypes.anyType.coneType
      argumentList = buildArgumentList {
        for (call in getClassCalls) {
          arguments += call
        }
      }
    }

    val annotationType =
      ConeClassLikeTypeImpl(
        ConeClassLikeLookupTagImpl(ClassIds.CONTRIBUTES_TO),
        emptyArray(),
        isMarkedNullable = false,
      )
    val annotationClassSymbol =
      session.symbolProvider.getClassLikeSymbolByClassId(ClassIds.CONTRIBUTES_TO)!!
    val constructorSymbol =
      (annotationClassSymbol as FirClassSymbol<*>)
        .declarationSymbols
        .filterIsInstance<FirConstructorSymbol>()
        .first()
    val scopeParam = constructorSymbol.fir.valueParameters.first { it.name == ArgNames.SCOPE }
    val replacesParam = constructorSymbol.fir.valueParameters.first { it.name == ArgNames.REPLACES }

    return buildAnnotationCall {
      annotationTypeRef = annotationType.toFirResolvedTypeRef()
      argumentMapping = buildAnnotationArgumentMapping {
        mapping[ArgNames.SCOPE] = scopeArg
        mapping[ArgNames.REPLACES] = arrayLiteral
      }
      argumentList =
        buildResolvedArgumentList(
          original = null,
          mapping = linkedMapOf(
            scopeArg to scopeParam,
            arrayLiteral to replacesParam,
          ),
        )
      calleeReference = buildResolvedNamedReference {
        name = ClassIds.CONTRIBUTES_TO.shortClassName
        resolvedSymbol = constructorSymbol
      }
      containingDeclarationSymbol = owner
      annotationResolvePhase = FirAnnotationResolvePhase.Types
    }
  }

  private fun findQualifierAnnotation(
    classSymbol: FirClassSymbol<*>,
  ): org.jetbrains.kotlin.fir.expressions.FirAnnotation? {
    for (annotation in classSymbol.resolvedAnnotationsWithArguments) {
      val annotationClassId = annotation.toAnnotationClassIdSafe(session) ?: continue
      if (annotationClassId == ContributesServiceIds.CONTRIBUTES_SERVICE_CLASS_ID) continue
      val annotationSymbol =
        session.symbolProvider.getClassLikeSymbolByClassId(annotationClassId)
          as? FirClassSymbol<*> ?: continue
      val isQualifier =
        annotationSymbol.resolvedCompilerAnnotationsWithClassIds.any {
          it.toAnnotationClassIdSafe(session) in ClassIds.QUALIFIER_CLASS_IDS
        }
      if (isQualifier) return annotation
    }
    return null
  }

  private fun buildSimpleAnnotation(
    classId: ClassId,
  ): org.jetbrains.kotlin.fir.expressions.FirAnnotation {
    val annotationType =
      ConeClassLikeTypeImpl(
        ConeClassLikeLookupTagImpl(classId),
        emptyArray(),
        isMarkedNullable = false,
      )
    return buildAnnotation {
      annotationTypeRef = annotationType.toFirResolvedTypeRef()
      argumentMapping = buildAnnotationArgumentMapping()
    }
  }

  /**
   * Build an annotation as [FirAnnotationCall] so Metro recognizes it. Metro's `metroAnnotations()`
   * checks `annotation !is FirAnnotationCall` and skips plain [FirAnnotation] instances.
   */
  @OptIn(DirectDeclarationsAccess::class)
  private fun buildSimpleAnnotationCall(
    classId: ClassId,
    containingSymbol: FirBasedSymbol<*>,
  ): FirAnnotationCall {
    val annotationType =
      ConeClassLikeTypeImpl(
        ConeClassLikeLookupTagImpl(classId),
        emptyArray(),
        isMarkedNullable = false,
      )
    return buildAnnotationCall {
      annotationTypeRef = annotationType.toFirResolvedTypeRef()
      argumentMapping = buildAnnotationArgumentMapping()
      calleeReference = buildResolvedNamedReference {
        name = classId.shortClassName
        resolvedSymbol =
          session.symbolProvider.getClassLikeSymbolByClassId(classId)!!.let {
            (it as FirClassSymbol<*>)
              .declarationSymbols
              .filterIsInstance<FirConstructorSymbol>()
              .first()
          }
      }
      containingDeclarationSymbol = containingSymbol
      annotationResolvePhase = FirAnnotationResolvePhase.Types
    }
  }

  /**
   * Build an annotation with scope argument as [FirAnnotationCall].
   *
   * Uses [buildResolvedArgumentList] so the FIR-to-IR converter recognizes the arguments. The
   * converter checks `argumentList is FirResolvedArgumentList` to extract the argument mapping â€” a
   * plain `buildArgumentList` would be treated as unresolved.
   */
  @OptIn(DirectDeclarationsAccess::class, SymbolInternals::class)
  private fun buildAnnotationCallWithScope(
    classId: ClassId,
    argName: Name,
    scopeArg: FirExpression,
    containingSymbol: FirBasedSymbol<*>,
  ): FirAnnotationCall {
    val annotationType =
      ConeClassLikeTypeImpl(
        ConeClassLikeLookupTagImpl(classId),
        emptyArray(),
        isMarkedNullable = false,
      )

    // Look up the annotation constructor and its parameter
    val annotationClassSymbol = session.symbolProvider.getClassLikeSymbolByClassId(classId)!!
    val constructorSymbol =
      (annotationClassSymbol as FirClassSymbol<*>)
        .declarationSymbols
        .filterIsInstance<FirConstructorSymbol>()
        .first()
    val scopeParam = constructorSymbol.fir.valueParameters.first { it.name == argName }

    return buildAnnotationCall {
      annotationTypeRef = annotationType.toFirResolvedTypeRef()
      argumentMapping = buildAnnotationArgumentMapping { mapping[argName] = scopeArg }
      argumentList =
        buildResolvedArgumentList(original = null, mapping = linkedMapOf(scopeArg to scopeParam))
      calleeReference = buildResolvedNamedReference {
        name = classId.shortClassName
        resolvedSymbol = constructorSymbol
      }
      containingDeclarationSymbol = containingSymbol
      annotationResolvePhase = FirAnnotationResolvePhase.Types
    }
  }

  @AutoService(MetroFirDeclarationGenerationExtension.Factory::class)
  public class Factory : MetroFirDeclarationGenerationExtension.Factory {
    override fun create(
      session: FirSession,
      options: MetroOptions,
    ): MetroFirDeclarationGenerationExtension = ContributesServiceFir(session)
  }
}
