package com.squareup.metro.extensions.featureflag

import com.fueledbycaffeine.autoservice.AutoService
import com.squareup.metro.extensions.ArgNames
import com.squareup.metro.extensions.ClassIds
import com.squareup.metro.extensions.Keys.ContributesFeatureFlagGeneratorKey
import com.squareup.metro.extensions.fir.buildAnnotationCallWithScope
import com.squareup.metro.extensions.fir.buildFirFunction
import com.squareup.metro.extensions.fir.hasAnnotation
import dev.zacsweers.metro.compiler.MetroOptions
import dev.zacsweers.metro.compiler.api.fir.MetroFirDeclarationGenerationExtension
import org.jetbrains.kotlin.descriptors.ClassKind
import org.jetbrains.kotlin.descriptors.Modality
import org.jetbrains.kotlin.descriptors.Visibilities
import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.fir.declarations.DirectDeclarationsAccess
import org.jetbrains.kotlin.fir.declarations.FirDeclaration
import org.jetbrains.kotlin.fir.declarations.FirResolvePhase
import org.jetbrains.kotlin.fir.declarations.builder.buildRegularClass
import org.jetbrains.kotlin.fir.declarations.impl.FirResolvedDeclarationStatusImpl
import org.jetbrains.kotlin.fir.declarations.origin
import org.jetbrains.kotlin.fir.expressions.FirAnnotationCall
import org.jetbrains.kotlin.fir.expressions.FirAnnotationResolvePhase
import org.jetbrains.kotlin.fir.expressions.FirExpression
import org.jetbrains.kotlin.fir.expressions.builder.buildAnnotationArgumentMapping
import org.jetbrains.kotlin.fir.expressions.builder.buildAnnotationCall
import org.jetbrains.kotlin.fir.expressions.builder.buildArgumentList
import org.jetbrains.kotlin.fir.expressions.builder.buildGetClassCall
import org.jetbrains.kotlin.fir.expressions.builder.buildResolvedQualifier
import org.jetbrains.kotlin.fir.extensions.FirDeclarationPredicateRegistrar
import org.jetbrains.kotlin.fir.extensions.NestedClassGenerationContext
import org.jetbrains.kotlin.fir.extensions.predicateBasedProvider
import org.jetbrains.kotlin.fir.moduleData
import org.jetbrains.kotlin.fir.references.builder.buildResolvedNamedReference
import org.jetbrains.kotlin.fir.resolve.providers.symbolProvider
import org.jetbrains.kotlin.fir.scopes.kotlinScopeProvider
import org.jetbrains.kotlin.fir.symbols.FirBasedSymbol
import org.jetbrains.kotlin.fir.symbols.impl.ConeClassLikeLookupTagImpl
import org.jetbrains.kotlin.fir.symbols.impl.FirClassLikeSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirClassSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirConstructorSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirNamedFunctionSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirRegularClassSymbol
import org.jetbrains.kotlin.fir.toEffectiveVisibility
import org.jetbrains.kotlin.fir.toFirResolvedTypeRef
import org.jetbrains.kotlin.fir.types.impl.ConeClassLikeTypeImpl
import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name

/**
 * Generates a nested `FeatureFlagContribution` interface for classes annotated with
 * `@ContributesFeatureFlag` or `@ContributesDynamicConfigurationFlag`.
 *
 * Given:
 * ```
 * @ContributesFeatureFlag(description = "My flag", removeBy = Date(April, 1, 2030))
 * object MyFlag : BooleanFeatureFlag("flagKey", DeviceId)
 * ```
 *
 * This generates:
 * ```
 * @ContributesTo(AppScope::class)
 * interface FeatureFlagContribution {
 *   @Provides @IntoSet
 *   fun providesMyFlag(): FeatureFlag
 * }
 * ```
 *
 * The scope is always `AppScope` â€” the real annotations don't have a scope parameter, matching the
 * original KSP processor which hardcoded `AppScope::class`.
 *
 * The function body is generated by [ContributesFeatureFlagIrExtension] in the IR phase as `return
 * MyFlag` (the object instance).
 *
 * Functions are added directly to the class's declarations list (rather than through
 * `getCallableNamesForClass`/`generateFunctions`) so Metro can see them when deciding what nested
 * classes to generate (e.g., ProvidesFactory).
 */
public class ContributesFeatureFlagFir(session: FirSession) :
  MetroFirDeclarationGenerationExtension(session) {

  override fun FirDeclarationPredicateRegistrar.registerPredicates() {
    register(ContributesFeatureFlagIds.PREDICATE)
  }

  override fun getContributionHints(): List<ContributionHint> {
    return session.predicateBasedProvider
      .getSymbolsByPredicate(ContributesFeatureFlagIds.PREDICATE)
      .filterIsInstance<FirRegularClassSymbol>()
      .mapNotNull { classSymbol ->
        if (findMatchingAnnotationClassId(classSymbol) == null) return@mapNotNull null
        val nestedInterfaceClassId =
          classSymbol.classId.createNestedClassId(ContributesFeatureFlagIds.NESTED_INTERFACE_NAME)
        ContributionHint(contributingClassId = nestedInterfaceClassId, scope = ClassIds.APP_SCOPE)
      }
  }

  override fun getNestedClassifiersNames(
    classSymbol: FirClassSymbol<*>,
    context: NestedClassGenerationContext,
  ): Set<Name> {
    if (findMatchingAnnotationClassId(classSymbol) != null) {
      return setOf(ContributesFeatureFlagIds.NESTED_INTERFACE_NAME)
    }
    return emptySet()
  }

  override fun generateNestedClassLikeDeclaration(
    owner: FirClassSymbol<*>,
    name: Name,
    context: NestedClassGenerationContext,
  ): FirClassLikeSymbol<*>? {
    if (name != ContributesFeatureFlagIds.NESTED_INTERFACE_NAME) return null
    if (findMatchingAnnotationClassId(owner) == null) return null

    val scopeArg = buildAppScopeClassExpression() ?: return null

    val nestedClassId = owner.classId.createNestedClassId(name)
    val classSymbol = FirRegularClassSymbol(nestedClassId)

    val providesFunction = buildProvidesFunction(nestedClassId, owner)

    val klass = buildRegularClass {
      resolvePhase = FirResolvePhase.BODY_RESOLVE
      moduleData = session.moduleData
      origin = ContributesFeatureFlagGeneratorKey.origin
      source = owner.source
      classKind = ClassKind.INTERFACE
      scopeProvider = session.kotlinScopeProvider
      this.name = nestedClassId.shortClassName
      symbol = classSymbol
      status =
        FirResolvedDeclarationStatusImpl(
          Visibilities.Public,
          Modality.ABSTRACT,
          Visibilities.Public.toEffectiveVisibility(owner, forClass = true),
        )
      superTypeRefs += session.builtinTypes.anyType
      annotations +=
        buildAnnotationCallWithScope(
          ClassIds.CONTRIBUTES_TO,
          ArgNames.SCOPE,
          scopeArg,
          owner,
          session,
        )
      declarations += providesFunction
    }

    return klass.symbol
  }

  /** Build a synthetic `AppScope::class` expression for the hardcoded scope. */
  private fun buildAppScopeClassExpression(): FirExpression? {
    val appScopeClassId = ClassIds.APP_SCOPE
    val appScopeType =
      ConeClassLikeTypeImpl(
        ConeClassLikeLookupTagImpl(appScopeClassId),
        emptyArray(),
        isMarkedNullable = false,
      )
    val kClassClassId = ClassId(FqName("kotlin.reflect"), Name.identifier("KClass"))
    val kClassType =
      ConeClassLikeTypeImpl(
        ConeClassLikeLookupTagImpl(kClassClassId),
        arrayOf(appScopeType),
        isMarkedNullable = false,
      )
    val appScopeSymbol =
      session.symbolProvider.getClassLikeSymbolByClassId(appScopeClassId) ?: return null

    return buildGetClassCall {
      coneTypeOrNull = kClassType
      argumentList = buildArgumentList {
        arguments += buildResolvedQualifier {
          packageFqName = appScopeClassId.packageFqName
          relativeClassFqName = appScopeClassId.relativeClassName
          coneTypeOrNull = appScopeType
          symbol = appScopeSymbol
          resolvedToCompanionObject = false
        }
      }
    }
  }

  /**
   * Build the `@Provides @IntoSet` function that returns `FeatureFlag`.
   *
   * Generates: `@Provides @IntoSet fun providesMyFlag(): FeatureFlag`
   */
  private fun buildProvidesFunction(
    classId: ClassId,
    outerOwner: FirClassSymbol<*>,
  ): FirDeclaration {
    val outerClassId = outerOwner.classId
    val functionName = "provides${outerClassId.shortClassName.identifier}"
    val callableId = CallableId(classId, Name.identifier(functionName))

    val featureFlagType =
      ConeClassLikeTypeImpl(
        ConeClassLikeLookupTagImpl(ClassIds.FEATURE_FLAG),
        emptyArray(),
        isMarkedNullable = false,
      )
    val dispatchType =
      ConeClassLikeTypeImpl(
        ConeClassLikeLookupTagImpl(classId),
        emptyArray(),
        isMarkedNullable = false,
      )

    val functionSymbol = FirNamedFunctionSymbol(callableId)

    return buildFirFunction {
      resolvePhase = FirResolvePhase.BODY_RESOLVE
      moduleData = session.moduleData
      origin = ContributesFeatureFlagGeneratorKey.origin
      symbol = functionSymbol
      name = callableId.callableName
      returnTypeRef = featureFlagType.toFirResolvedTypeRef()
      dispatchReceiverType = dispatchType
      status =
        FirResolvedDeclarationStatusImpl(
          Visibilities.Public,
          Modality.OPEN,
          Visibilities.Public.toEffectiveVisibility(outerOwner, forClass = true),
        )
      annotations += buildSimpleAnnotationCall(ClassIds.PROVIDES, functionSymbol)
      annotations += buildSimpleAnnotationCall(ClassIds.INTO_SET, functionSymbol)
    }
  }

  /**
   * Returns the matching annotation ClassId if the class has one of the feature flag annotations.
   */
  private fun findMatchingAnnotationClassId(classSymbol: FirClassSymbol<*>): ClassId? {
    for (annotationClassId in ContributesFeatureFlagIds.ANNOTATION_CLASS_IDS) {
      if (hasAnnotation(classSymbol, annotationClassId, session)) return annotationClassId
    }
    return null
  }

  /**
   * Build an annotation as [FirAnnotationCall] so Metro recognizes it. Metro's `metroAnnotations()`
   * checks `annotation !is FirAnnotationCall` and skips plain `FirAnnotation` instances.
   */
  @OptIn(DirectDeclarationsAccess::class)
  private fun buildSimpleAnnotationCall(
    classId: ClassId,
    containingSymbol: FirBasedSymbol<*>,
  ): FirAnnotationCall {
    val annotationType =
      ConeClassLikeTypeImpl(
        ConeClassLikeLookupTagImpl(classId),
        emptyArray(),
        isMarkedNullable = false,
      )
    return buildAnnotationCall {
      annotationTypeRef = annotationType.toFirResolvedTypeRef()
      argumentMapping = buildAnnotationArgumentMapping()
      calleeReference = buildResolvedNamedReference {
        name = classId.shortClassName
        resolvedSymbol =
          session.symbolProvider.getClassLikeSymbolByClassId(classId)!!.let {
            (it as FirClassSymbol<*>)
              .declarationSymbols
              .filterIsInstance<FirConstructorSymbol>()
              .first()
          }
      }
      containingDeclarationSymbol = containingSymbol
      annotationResolvePhase = FirAnnotationResolvePhase.Types
    }
  }

  @AutoService(MetroFirDeclarationGenerationExtension.Factory::class)
  public class Factory : MetroFirDeclarationGenerationExtension.Factory {
    override fun create(
      session: FirSession,
      options: MetroOptions,
    ): MetroFirDeclarationGenerationExtension = ContributesFeatureFlagFir(session)
  }
}
