package com.squareup.metro.extensions.featureflag

import com.fueledbycaffeine.autoservice.AutoService
import com.squareup.metro.extensions.ClassIds
import com.squareup.metro.extensions.fir.hasAnnotation
import dev.zacsweers.metro.compiler.MetroOptions
import dev.zacsweers.metro.compiler.api.fir.MetroContributionExtension
import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.fir.extensions.FirDeclarationPredicateRegistrar
import org.jetbrains.kotlin.fir.extensions.predicateBasedProvider
import org.jetbrains.kotlin.fir.resolve.defaultType
import org.jetbrains.kotlin.fir.resolve.providers.symbolProvider
import org.jetbrains.kotlin.fir.scopes.getSingleClassifier
import org.jetbrains.kotlin.fir.scopes.impl.declaredMemberScope
import org.jetbrains.kotlin.fir.symbols.impl.FirRegularClassSymbol
import org.jetbrains.kotlin.name.ClassId

/**
 * Implements [MetroContributionExtension] to tell Metro's `ContributedInterfaceSupertypeGenerator`
 * about contributions from our generated `FeatureFlagContribution` interfaces.
 *
 * This is necessary because Metro's predicate-based provider only discovers source declarations and
 * declarations generated by generators that registered the `@ContributesTo` predicate. Our
 * `FeatureFlagContribution` is generated by [ContributesFeatureFlagFir] (which registers a
 * predicate for `@ContributesFeatureFlag` / `@ContributesDynamicConfigurationFlag`), so Metro's
 * in-compilation discovery doesn't see it.
 *
 * The scope is always `AppScope` â€” matching the original KSP processor.
 */
public class ContributesFeatureFlagMetroExtension(private val session: FirSession) :
  MetroContributionExtension {

  private val predicate = ContributesFeatureFlagIds.PREDICATE

  private val annotatedClasses by lazy {
    session.predicateBasedProvider
      .getSymbolsByPredicate(predicate)
      .filterIsInstance<FirRegularClassSymbol>()
      .toList()
  }

  override fun FirDeclarationPredicateRegistrar.registerPredicates() {
    register(predicate)
  }

  override fun getContributions(
    scopeClassId: ClassId
  ): List<MetroContributionExtension.Contribution> {
    // Feature flags are always contributed to AppScope.
    if (scopeClassId != ClassIds.APP_SCOPE) return emptyList()

    return annotatedClasses.mapNotNull { parentSymbol ->
      if (findMatchingAnnotationClassId(parentSymbol) == null) return@mapNotNull null

      val contributionInterfaceClassId =
        parentSymbol.classId.createNestedClassId(ContributesFeatureFlagIds.NESTED_INTERFACE_NAME)

      val contributionSymbol =
        session.symbolProvider.getClassLikeSymbolByClassId(contributionInterfaceClassId)
          as? FirRegularClassSymbol ?: return@mapNotNull null

      // Access the declared member scope to trigger Metro's FIR generator, which creates the
      // MetroContribution nested class inside our FeatureFlagContribution. Without this, Metro
      // wouldn't see our contribution.
      val scope = contributionSymbol.declaredMemberScope(session, memberRequiredPhase = null)
      val metroContributionName =
        scope.getClassifierNames().firstOrNull { it.identifier.startsWith("MetroContributionTo") }
          ?: return@mapNotNull null

      val metroContributionSymbol =
        scope.getSingleClassifier(metroContributionName) as? FirRegularClassSymbol
          ?: return@mapNotNull null

      MetroContributionExtension.Contribution(
        supertype = metroContributionSymbol.defaultType(),
        replaces = emptyList(),
        originClassId = parentSymbol.classId,
      )
    }
  }

  private fun findMatchingAnnotationClassId(classSymbol: FirRegularClassSymbol): ClassId? {
    for (annotationClassId in ContributesFeatureFlagIds.ANNOTATION_CLASS_IDS) {
      if (hasAnnotation(classSymbol, annotationClassId, session)) return annotationClassId
    }
    return null
  }

  @AutoService(MetroContributionExtension.Factory::class)
  public class Factory : MetroContributionExtension.Factory {
    override fun create(session: FirSession, options: MetroOptions): MetroContributionExtension {
      return ContributesFeatureFlagMetroExtension(session)
    }
  }
}
